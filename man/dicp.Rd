% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tramicp.R
\name{dicp}
\alias{dicp}
\title{Invariant causal prediction for transformation models}
\usage{
dicp(
  formula,
  data,
  env,
  modFUN,
  trt = NULL,
  verbose = TRUE,
  type = c("residual", "wald", "partial", "mcheck", "confint"),
  test = "indep",
  controls = dicp_controls(match.arg(type), test),
  baseline_fixed = TRUE,
  alpha = 0.05,
  ...
)
}
\arguments{
\item{formula}{Formula including response and shift terms}

\item{data}{Data.frame containing response and explanatory variables}

\item{env}{Character, name of environmental variable}

\item{modFUN}{Model function from package 'tram', i.e. \code{BoxCox},
\code{Colr}, \code{Polr}, \code{Lm}, \code{Coxph}, \code{Survreg},
\code{Lehmann}. Standard implementation \code{lm} is also supported.}

\item{trt}{Character, supply only when \code{type = "partial"}, treatment
variable. Ignored otherwise}

\item{verbose}{Logical, whether output should be verbose (default \code{TRUE})}

\item{type}{Character, type of invariance (\code{"residual"}, \code{"wald"},
or \code{"partial"})}

\item{test}{Character, type of test to be used (\code{"HSIC"}, \code{"t.test"},
\code{"var.test"}, \code{"wald"}) or custom function for testing
invariance.}

\item{controls}{Controls for the used tests, see \code{dicp_controls}}

\item{baseline_fixed}{Logical, whether baseline transformation is fixed
(\code{TRUE}) or allowed to vary across environments (\code{FALSE}).
Defaults to \code{TRUE}, i.e. a fixed baseline transformation}

\item{alpha}{Level of invariance test, default}

\item{...}{Further arguments passed to \code{modFUN}}
}
\value{
Object of class \code{"dICP"}, containing the invariant set (if exists),
    pvalues from all invariance tests and the tests themselves
}
\description{
Invariant causal prediction for transformation models
}
\examples{
set.seed(123)
d <- dgp_dicp(n = 1e3, mod = "polr")
dicp(Y ~ X1 + X2 + X3, data = d, env = "E", modFUN = Polr, type = "confint")
dicp(Y ~ X1 + X2 + X3, data = d, env = "E", modFUN = Polr, type = "wald")
dicp(Y ~ X1 + X2 + X3, data = d, env = "E",
   modFUN = tramicp:::.mod_from_name("polr"),
   type = "wald", weights = abs(rnorm(nrow(d))))
dicp(Y ~ X1 + X2 + X3, data = d, env = "E", modFUN = Polr, type = "residual")
dicp(Y ~ X1 + X2 + X3, data = d, env = "E", modFUN = Polr, type = "residual",
     test = "indep")

}
